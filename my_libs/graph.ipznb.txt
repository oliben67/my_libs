{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import functools\n",
    "import inspect\n",
    "import typing\n",
    "\n",
    "from pydantic import BaseModel, Field\n",
    "\n",
    "import logging\n",
    "logging.basicConfig(\n",
    "    filename=\"/home/scor/sources/cembalo/cembalo3/conditional.log\",\n",
    "    filemode=\"a\",\n",
    "    format=\"%(asctime)s,%(msecs)03d %(name)s %(levelname)s %(message)s\",\n",
    "    datefmt=\"%Y-%m-%d %H:%M:%S\",\n",
    "    level=logging.DEBUG,\n",
    ")\n",
    "logger = logging.getLogger(__name__)\n",
    "\n",
    "class conditional(BaseModel):\n",
    "    model_config = {\"arbitrary_types_allowed\": True}\n",
    "\n",
    "    cls: typing.Type = Field(\n",
    "        None,\n",
    "        description=\"Class containing an instance of the decorator\",\n",
    "        init=False,\n",
    "    )\n",
    "    defined_properties: typing.Optional[dict] = Field(\n",
    "        {},\n",
    "        description=\"Condition defined properties of the class\",\n",
    "        init=False,\n",
    "    )\n",
    "\n",
    "    def __init__(self, cls) -> typing.Type:\n",
    "        super().__init__(cls=cls)\n",
    "        conditional_properties = [\n",
    "            m for m in inspect.getmembers(self.cls) if isinstance(m[1], conditional.class_property) and not m[1].condition_evaluated and m[1].cls is None\n",
    "        ]\n",
    "\n",
    "        if len(conditional_properties) > 0:\n",
    "            def get_cond_attr(_, item):\n",
    "                if item not in self.defined_properties:\n",
    "                    raise AttributeError(f\"'{{cls.__name__}}' object has no attribute '{{item}}'\")\n",
    "                conditional_func = self.defined_properties[item]\n",
    "                conditional_property = property(fget=conditional_func, doc=conditional_property.func.__doc__)\n",
    "                return conditional_property.__get__(self.cls, self.cls)\n",
    "            self.cls.__getattr__ = get_cond_attr\n",
    "\n",
    "        for property_name, conditional_property in conditional_properties:\n",
    "            if conditional_property.func and not conditional_property.condition_evaluated:\n",
    "                context = {\"cls\": self.cls}\n",
    "                if not isinstance(conditional_property.condition, str):\n",
    "\n",
    "                    def _condition():\n",
    "                        return conditional_property.condition()\n",
    "\n",
    "                    context[\"_condition\"] = _condition\n",
    "                    condition_evaluation = \"_condition()\"\n",
    "                else:\n",
    "                    condition_evaluation = conditional_property.condition\n",
    "\n",
    "                if eval(condition_evaluation, context):\n",
    "                    conditional_property.cls = self.cls\n",
    "                    conditional_property.condition_evaluated = True\n",
    "                    self.defined_properties[property_name] = conditional_property.func\n",
    "            else:\n",
    "                delattr(cls, property_name)\n",
    "\n",
    "    # def __getattr__(self, item):\n",
    "    #     return self.cls.__getattr__(self.cls, item)\n",
    "\n",
    "    def __call__(self, *args, **kwargs):\n",
    "        logger.debug(f\"__call__(self, *{args[0]}, **{kwargs}) called\")\n",
    "        if self.cls is None:\n",
    "            if len(args) == 1 and inspect.isclass(args[0]):\n",
    "                logger.debug(f\"Creating conditional for class: {args[0]}\")\n",
    "                return conditional(cls=args[0]).cls\n",
    "            else:\n",
    "                raise ValueError(\"Target class must be provided as the first argument\")\n",
    "        return self.cls\n",
    "\n",
    "    class class_property(BaseModel):\n",
    "        \"\"\"\n",
    "        A class property that is only available if the condition is met.\n",
    "        \"\"\"\n",
    "\n",
    "        model_config = {\"arbitrary_types_allowed\": True}\n",
    "\n",
    "        condition: typing.Union[typing.Callable[[], bool], str] = Field(\n",
    "            description=\"A callable or a string that returns a boolean or a string representing the condition.\",\n",
    "        )\n",
    "        condition_evaluated: bool = Field(\n",
    "            False,\n",
    "            description=\"The function to be decorated.\",\n",
    "            init=False,\n",
    "        )\n",
    "        func: typing.Optional[typing.Callable[..., typing.Any]] = Field(\n",
    "            None,\n",
    "            description=\"The function to be decorated.\",\n",
    "            init=False,\n",
    "        )\n",
    "        cls: typing.Optional[typing.Type] = Field(\n",
    "            None,\n",
    "            description=\"Class containing an instance of the decorator\",\n",
    "            init=False,\n",
    "        )\n",
    "\n",
    "        def __init__(self, condition: typing.Union[typing.Callable[[], bool], str]):\n",
    "            super().__init__(condition=condition)\n",
    "\n",
    "        def __call__(self, *args, **kwargs):\n",
    "            if self.func is None:\n",
    "                func = args[0] if len(args) == 1 else None\n",
    "                if not callable(func):\n",
    "                    raise ValueError(\"Condition must be a callable\")\n",
    "                self.func = func\n",
    "            return self\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'conditional' object has no attribute 'conditional_property_one'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[3], line 14\u001b[0m\n\u001b[1;32m     11\u001b[0m \u001b[38;5;250m        \u001b[39m\u001b[38;5;124;03m\"\"\"This property is always available.\"\"\"\u001b[39;00m\n\u001b[1;32m     12\u001b[0m         \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mThis property is always available.\u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mcls\u001b[39m\u001b[38;5;241m.\u001b[39mfart()\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m---> 14\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[43mTestingClassOne\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mconditional_property_one\u001b[49m)\n\u001b[1;32m     15\u001b[0m \u001b[38;5;28mprint\u001b[39m(TestingClassOne\u001b[38;5;241m.\u001b[39mconditional_property_one)\n",
      "File \u001b[0;32m~/.local/lib/python3.11/site-packages/pydantic/main.py:710\u001b[0m, in \u001b[0;36mBaseModel.__getattr__\u001b[0;34m(self, item)\u001b[0m\n\u001b[1;32m    707\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28msuper\u001b[39m()\u001b[38;5;241m.\u001b[39m\u001b[38;5;21m__getattribute__\u001b[39m(item)  \u001b[38;5;66;03m# Raises AttributeError if appropriate\u001b[39;00m\n\u001b[1;32m    708\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m    709\u001b[0m     \u001b[38;5;66;03m# this is the current error\u001b[39;00m\n\u001b[0;32m--> 710\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mAttributeError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{\u001b[39;00m\u001b[38;5;28mtype\u001b[39m(\u001b[38;5;28mself\u001b[39m)\u001b[38;5;241m.\u001b[39m\u001b[38;5;18m__name__\u001b[39m\u001b[38;5;132;01m!r}\u001b[39;00m\u001b[38;5;124m object has no attribute \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mitem\u001b[38;5;132;01m!r}\u001b[39;00m\u001b[38;5;124m'\u001b[39m)\n",
      "\u001b[0;31mAttributeError\u001b[0m: 'conditional' object has no attribute 'conditional_property_one'"
     ]
    }
   ],
   "source": [
    "import time\n",
    "\n",
    "@conditional\n",
    "class TestingClassOne:\n",
    "    @classmethod\n",
    "    def fart(cls):\n",
    "        return f\"fart {time.time()}\"\n",
    "\n",
    "    @conditional.class_property(condition=lambda: True)\n",
    "    def conditional_property_one(cls):\n",
    "        \"\"\"This property is always available.\"\"\"\n",
    "        return f\"This property is always available.{cls.fart()}\"\n",
    "\n",
    "print(TestingClassOne.conditional_property_one)\n",
    "print(TestingClassOne.conditional_property_one)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This class property is always available in TestingClassTwo. [1748867035.4879007]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f9808d32ed0>. [1748867035.4879787]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867036.4881074]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f9808336110>. [1748867036.4882092]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867037.4883497]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f9808337450>. [1748867037.4884803]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867038.4886208]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f9808337590>. [1748867038.4887311]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867039.488893]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f9808336690>. [1748867039.489]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867040.4891405]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f98083362d0>. [1748867040.489244]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867041.489389]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f9808336750>. [1748867041.4894848]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867042.489655]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f98182bef90>. [1748867042.48977]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867043.489917]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f98082b7910>. [1748867043.4900699]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "This class property is always available in TestingClassTwo. [1748867044.4902194]\n",
      "This member property is always available in <__main__.TestingClassTwo object at 0x7f98083ad950>. [1748867044.490327]\n",
      "(True)\n",
      "False False\n",
      "False False\n",
      "False False\n",
      "False False\n"
     ]
    }
   ],
   "source": [
    "from abc import ABC, abstractmethod\n",
    "from pprint import pformat\n",
    "import typing\n",
    "from pydantic import BaseModel, Field\n",
    "import inspect\n",
    "\n",
    "import logging\n",
    "logging.basicConfig(\n",
    "    filename=\"/home/scor/sources/cembalo/cembalo3/conditional.log\",\n",
    "    filemode=\"a\",\n",
    "    format=\"%(asctime)s,%(msecs)03d %(name)s %(levelname)s %(message)s\",\n",
    "    datefmt=\"%Y-%m-%d %H:%M:%S\",\n",
    "    level=logging.DEBUG,\n",
    ")\n",
    "logger = logging.getLogger(__name__)\n",
    "\n",
    "class ConditionalProperty(ABC, BaseModel):\n",
    "    \"\"\"\n",
    "    A class property that is only available if the condition is met.\n",
    "    \"\"\"\n",
    "\n",
    "    model_config = {\"arbitrary_types_allowed\": True}\n",
    "\n",
    "    condition: typing.Union[typing.Callable[[], bool], str] = Field(\n",
    "        description=\"A callable or a string that returns a boolean or a string \\\n",
    "representing the condition.\",\n",
    "    )\n",
    "    func: typing.Optional[typing.Callable[..., typing.Any]] = Field(\n",
    "        None,\n",
    "        description=\"The function to be decorated.\",\n",
    "        init=False,\n",
    "    )\n",
    "\n",
    "    @abstractmethod\n",
    "    def __call__(self, *args, **kwargs):\n",
    "        \"\"\"\n",
    "        This method should be implemented by subclasses to define the behavior\n",
    "        of the conditional property.\n",
    "        It should return the value of the property if the condition is met.\n",
    "        \"\"\"\n",
    "        pass\n",
    "\n",
    "def generate_descriptor_class(func) -> typing.Type:\n",
    "    def __get__(_, instance, owner):\n",
    "        return func(instance)\n",
    "\n",
    "    return type(f\"Descriptor_{func.__name__}\", (object,), {\"__get__\": __get__})\n",
    "\n",
    "class conditional(type):\n",
    "    def __new__(mcls, *args, **kwargs):\n",
    "        # Here we check if the first argument is a class to allow the decorator\n",
    "        # to be used as a class decorator and pass additional arguments to it\n",
    "        cls = args[0] if len(args) > 0 else tuple()\n",
    "        if not inspect.isclass(cls):\n",
    "            logger.debug(\"first round\")\n",
    "            mcls.__args__ = args\n",
    "            mcls.__kwargs__ = kwargs\n",
    "            return mcls\n",
    "        logger.debug(\"second round\")\n",
    "        name = cls.__name__\n",
    "        bases = (cls,)\n",
    "        attrs = cls.__dict__.copy()\n",
    "\n",
    "        # Process conditional properties defined in the class\n",
    "        conditional_properties = {\n",
    "            m[0]: m[1] for m in inspect.getmembers(cls) if hasattr(m[1], \"__property_decorator__\")\n",
    "        }\n",
    "\n",
    "        for conditional_property_name, decorated_function in conditional_properties.items():\n",
    "            # to start with, we --always-- remove the function references from the class\n",
    "            delattr(cls, conditional_property_name)\n",
    "            del attrs[conditional_property_name]\n",
    "\n",
    "            property_decorator = decorated_function.__property_decorator__\n",
    "            if callable(property_decorator.condition):\n",
    "                condition_met = property_decorator.condition()\n",
    "            elif isinstance(property_decorator.condition, str):\n",
    "                condition_met = eval(property_decorator.condition, {\"cls\": cls})\n",
    "            if condition_met:\n",
    "                if isinstance(property_decorator, conditional.member_property):\n",
    "                    setattr(cls, conditional_property_name, generate_descriptor_class(decorated_function)())\n",
    "                    continue\n",
    "                if isinstance(property_decorator, conditional.class_property):\n",
    "                    setattr(mcls, conditional_property_name, generate_descriptor_class(decorated_function)())\n",
    "                    continue\n",
    "\n",
    "        if issubclass(args[0], BaseModel):\n",
    "            return cls\n",
    "        else:\n",
    "            logger.debug(f\"Creating class {name} with bases {bases} and attrs {attrs}\")\n",
    "            return super().__new__(mcls, name, bases, attrs)\n",
    "\n",
    "    class class_property(ConditionalProperty):\n",
    "        \"\"\"\n",
    "        A --class-- property that is only available if the condition is met.\n",
    "        \"\"\"\n",
    "        def __call__(self, *args, **kwargs):\n",
    "            if self.func is None:\n",
    "                func = args[0] if len(args) == 1 else None\n",
    "                if not callable(func):\n",
    "                    raise ValueError(\"Condition must be a callable\")\n",
    "                func.__property_decorator__ = self\n",
    "                self.func = func\n",
    "            return self.func\n",
    "\n",
    "    class member_property(class_property):\n",
    "        \"\"\"\n",
    "        A --member-- property that is only available if the condition is met.\n",
    "        \"\"\"\n",
    "        def __call__(self, *args, **kwargs):\n",
    "            if self.func is None:\n",
    "                func = args[0] if len(args) == 1 else None\n",
    "                if not callable(func):\n",
    "                    raise ValueError(\"Condition must be a callable\")\n",
    "                func.__property_decorator__ = self\n",
    "                self.func = func\n",
    "            return self.func\n",
    "\n",
    "import time\n",
    "\n",
    "test_obj_name = \"Boaty McBoatface\"\n",
    "\n",
    "@conditional\n",
    "class TestingClassTwo():\n",
    "    def __init__(self):\n",
    "        self.name = test_obj_name\n",
    "\n",
    "    @conditional.class_property(condition=lambda: True)\n",
    "    def conditional_class_property(cls):\n",
    "        \"\"\"This property is always available.\"\"\"\n",
    "        return f\"This class property is always available in {cls.__name__}. [{time.time()}]\"\n",
    "\n",
    "    @conditional.member_property(condition=lambda: True)\n",
    "    def conditional_member_property(self):\n",
    "        \"\"\"This property is always available.\"\"\"\n",
    "        return f\"This member property is always available in {self}. [{time.time()}]\"\n",
    "\n",
    "    @conditional.member_property(condition=lambda: True)\n",
    "    def conditional_member_id(self):\n",
    "        \"\"\"This property is always available.\"\"\"\n",
    "        return id(self)\n",
    "\n",
    "    @conditional.class_property(condition=lambda: False)\n",
    "    def unavailable_class_property(cls):\n",
    "        \"\"\"This property is never available.\"\"\"\n",
    "        return f\"This class property is never available in {cls.__name__}. [{time.time()}]\"\n",
    "\n",
    "    @conditional.member_property(condition=lambda: False)\n",
    "    def unavailable_member_property(self):\n",
    "        \"\"\"This property is never available.\"\"\"\n",
    "        return f\"This member property is never available for {self}. [{time.time()}]\"\n",
    "\n",
    "    @conditional.member_property(condition=\"False\")\n",
    "    def unavailable_member_property_str_condition(self):\n",
    "        \"\"\"This property is never available.\"\"\"\n",
    "        return f\"This member property is never available for {self}. [{time.time()}]\"\n",
    "\n",
    "    @conditional.member_property(condition=\"cls.__name__ == 'TestingClassThree'\")\n",
    "    def unavailable_member_property_context_str_condition(self):\n",
    "        \"\"\"This property is never available.\"\"\"\n",
    "        return f\"This member property is never available for {self}. [{time.time()}]\"\n",
    "\n",
    "    # @conditional.member_property(condition=f\"self.name != '{test_obj_name}'\")\n",
    "    # def conditional_member_property_context_str_condition(self):\n",
    "    #     \"\"\"This property is available.\"\"\"\n",
    "    #     return f\"This member property is available for {self}. [{time.time()}]\"\n",
    "\n",
    "for i in range(10):\n",
    "    print(TestingClassTwo.conditional_class_property)\n",
    "    testing_obj = TestingClassTwo()\n",
    "    print(testing_obj.conditional_member_property)\n",
    "    print(f\"({testing_obj.conditional_member_id == id(testing_obj)})\")\n",
    "    print(hasattr(TestingClassTwo, \"unavailable_class_property\"), False)\n",
    "    print(hasattr(TestingClassTwo(), \"unavailable_member_property\"), False)\n",
    "    print(hasattr(TestingClassTwo(), \"unavailable_member_property_str_condition\"), False)\n",
    "    print(hasattr(TestingClassTwo(), \"unavailable_member_property_context_str_condition\"), False)\n",
    "    time.sleep(1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Subtracting {'a': 1} from {'a': 'A'}\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "execution_count": 162,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from pydantic import BaseModel, Field, root_validator\n",
    "import typing\n",
    "import uuid\n",
    "import enum\n",
    "\n",
    "\n",
    "BASE_CLASSES = [\"Graph\", \"Edge\", \"Vertex\"]\n",
    "DEFAULTS = [\"base_model\", \"no_set\"]\n",
    "\n",
    "class GraphItemBaseType(enum.Enum):\n",
    "    def __new__(cls, value):\n",
    "        obj = object.__new__(cls)\n",
    "        obj._value_ = value\n",
    "        obj._name_ = value.upper()\n",
    "        return obj\n",
    "\n",
    "    @classmethod\n",
    "    def list_values(cls) -> list[typing.Any]:\n",
    "        return [member.value for member in cls]\n",
    "\n",
    "    @classmethod\n",
    "    def list_names(cls) -> list[str]:\n",
    "        return [member.name for member in cls]\n",
    "\n",
    "    @classmethod\n",
    "    def registry(cls) -> dict[str, typing.Any]:\n",
    "        return {member.name: member.value for member in cls}\n",
    "\n",
    "    @classmethod\n",
    "    def create(cls, name: str = None, members: list[str] = None) -> typing.Type[\"GraphItemBaseType\"]:\n",
    "        \"\"\"\n",
    "        Dynamically create a new enum class with the given name and members.\n",
    "        \"\"\"\n",
    "        members = [\"Context\"] + (BASE_CLASSES if members is None else members)\n",
    "        if set(DEFAULTS).intersection(members) == set():\n",
    "            members += DEFAULTS\n",
    "        name = \"ItemBaseTypes\" if name is None else name\n",
    "        return GraphItemBaseType(name, {member.upper(): member for member in members})\n",
    "\n",
    "\n",
    "class _Model(BaseModel):\n",
    "    base_types: typing.ClassVar[enum.Enum] = GraphItemBaseType.create()\n",
    "\n",
    "    model_config = {\"arbitrary_types_allowed\": True}\n",
    "\n",
    "    id: str = Field(\n",
    "        default_factory=lambda: str(uuid.uuid4()),\n",
    "        description=\"Unique identifier for the edge or vertex\",\n",
    "    )\n",
    "    label: typing.Optional[str] = Field(\n",
    "        None,\n",
    "        description=\"Label for the edge or vertex\",\n",
    "    )\n",
    "    data: dict = Field(\n",
    "        None,\n",
    "        description=\"Data stored in the edge or vertex\",\n",
    "    )\n",
    "    type: typing.ClassVar[GraphItemBaseType] = Field(\n",
    "        default=GraphItemBaseType.create()[\"BASE_MODEL\"],\n",
    "        description=\"Type of the edge or vertex\",\n",
    "    )\n",
    "\n",
    "    def __init_subclass__ (cls, **kwargs):\n",
    "        if cls.__mro__[1] is _Model:\n",
    "            cls.__base_model_class__ = cls\n",
    "        else:\n",
    "            try:\n",
    "                base_model_class = [parent_class for parent_class in cls.__mro__ if getattr(parent_class, \"__base_model_class__\", None) == parent_class][0]\n",
    "                cls.__base_model_class__ = base_model_class\n",
    "            except IndexError as iex:\n",
    "                raise ValueError(f\"Invalid graph item kind: {cls.__name__}. Must inherit from class generated with create_base_class() method.\") from iex\n",
    "            if len(cls.__mro__) == 5:\n",
    "                if cls.__name__.upper() not in cls.base_types.registry():\n",
    "                    raise ValueError(f\"Invalid graph item kind: {cls.__name__}. Your first generation models must have their name from {[]}.\")\n",
    "                cls.type = cls.base_types[cls.__name__.upper()]\n",
    "            else:\n",
    "                cls.type = cls.__mro__[1].type\n",
    "\n",
    "\n",
    "class MetaGraphModel(BaseModel.__class__):\n",
    "    def __new__(mcls, name, bases, attrs, **kwargs):\n",
    "\n",
    "        if hasattr(bases[0], \"type\") and hasattr(bases[0].type, \"name\") and bases[0].type.name == \"CONTEXT\":\n",
    "            raise ValueError(\"Cannot create a new graph item Context. This is reserved for the Context class.\")\n",
    "\n",
    "        # check if the name is a valid graph item kind\n",
    "        is_base_class = kwargs.get(\"base_class\", False)\n",
    "\n",
    "        # check if the name is a valid graph item kind\n",
    "        if not is_base_class and name.lower() not in _Model.base_types.registry() and bases == (_Model,):\n",
    "            raise ValueError(f\"Invalid graph item kind: {name}. Must be one of {list(_Model.base_types.registry().values())}\")\n",
    "\n",
    "        # create the class\n",
    "        attrs.update({\"__module__\": __name__})\n",
    "        return super().__new__(mcls, name, bases, attrs, **kwargs)\n",
    "\n",
    "\n",
    "def create_base_class(class_name: str, bases: list[str] = None) -> typing.Type[_Model]:\n",
    "    return MetaGraphModel(class_name, (_Model,), {}, base_class=True)\n",
    "\n",
    "\n",
    "BaseGraphModel = create_base_class(\"BaseGraphModel\")\n",
    "\n",
    "BaseGraphModel.type\n",
    "\n",
    "class Context(BaseGraphModel):\n",
    "    pass\n",
    "\n",
    "\n",
    "class Graph(BaseGraphModel):\n",
    "    edges: typing.List[_Model] = []\n",
    "    vertices: typing.List[_Model] = []\n",
    "    instances: typing.ClassVar[list[\"Graph\"]] = []\n",
    "\n",
    "    def __init__(self, **kwargs):\n",
    "        super().__init__(**kwargs)\n",
    "        Graph.instances.append(self)\n",
    "\n",
    "class Vertex(BaseGraphModel):\n",
    "    pass\n",
    "\n",
    "class Wedgy(Vertex):\n",
    "    pass\n",
    "\n",
    "class Edge(BaseGraphModel):\n",
    "\n",
    "    def __add__(self, other):\n",
    "        print(other)\n",
    "\n",
    "    def __sub__(self, other):\n",
    "        if isinstance(other, dict):\n",
    "            print(f\"Subtracting {other} from {self.data}\")\n",
    "            return self\n",
    "\n",
    "class Edgy(Edge):\n",
    "    pass\n",
    "\n",
    "Vertex.type\n",
    "A = Edge(data={\"a\": \"A\"})\n",
    "B = Edge(data={\"b\": \"B\"})\n",
    "\n",
    "A - {\"a\": 1}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
